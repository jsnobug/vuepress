# 布局单位

## 基础

#### 物理像素（physical pixel）

就是反映显示屏的硬件条件，反映的就是显示屏内部led灯的数量，可以简单理解，一组三色led代表一个物理像素，当然根据屏幕物理属性以及处理led的方法不一样。强调这是物理的，因为这是一个纯硬件指标。比如我把屏幕锯了一半，物理像素就只有一半。

#### 渲染像素（render pixel）

是在系统内部对物理像素的分配进行再一次的调整，在pc上，渲染像素其实就是设置里边的分辨率。对于显示设备，系统为显示设备提供渲染尺寸，由显示设备的“缩放引擎”（带存储器阵列的数字视频处理器）处理。这种“缩放引擎”一般内部有一系列的合理分辨率和一个推荐分辨率。一般推荐分辨率就是最大渲染像素，也是设备的物理分辨率（为了最佳表现）。这是一个软硬件（偏硬）结合的缩放方案。由于部分设备不能设置渲染像素，所以下文部分场景为了简化模型，直接跳过渲染像素，直接等同于物理像素.

#### 逻辑像素/点（device point / device pixel / point ）

是为了调和距离不一样导致的差异，将所有设备根据距离，透视缩放到一个相等水平的观看距离之后得到的尺寸，是一个抽象的概念，这个单位就是ios开发的px，安卓开发的dp。对于pc，包括win（8+） linux，mac，由各自系统的或者对应软件（比如webview内部）提供的图像界面处理引擎处理进行缩放

在win上，可以通过显示设置缩放比例来调整部分应用的逻辑像素。对于linux，可以通过x和wayland的缩放比例来调整，而苹果，众所周知的hidpi

但是，由于这个是一个纯软件的方案，如果部分软件不遵循开发规则，或者使用老旧的api，就会导致逻辑像素不合理，导致缩放问题。例如win10中部分旧的软件在高分屏的设备会导致界面偏小。因为他们实际是使用的是渲染像素而不是逻辑像素

各种设备，手机，平板，笔记本等逻辑像素

手机：逻辑像素在3xx-4xx（短边）之间

平板：10寸平板7xx-8xx（短边）

笔记本：13寸 1280 （长边）

24寸显示屏：1920（长边）

你会发现如果设置width=device-width下，无论是否高分屏，在浏览器得到的screen.width仍然符合上述的尺寸

逻辑像素的引入，简单来说，就是为了消除了不同屏幕观看距离和不同ppi（见下文）之间的差异，衍生出来的一个虚拟的尺寸

#### ppi（pixel per inch）

每英寸像素，指的是屏幕在每英寸的**物理像素**，更高的ppi意味着屏幕的清晰度更佳。

所谓高分屏，其实就是指ppi大于同类设备的屏幕。比如对于桌面设备，大于96ppi。对于移动设备，大于160ppi

所谓视网膜屏，其实就是指在该观看距离内超出人类的辨认能力的屏幕。比如对于桌面设备，大于192ppi。对于移动设备大于326ppi

ppi，对于移动设备而言，一般来说ppi以160为一个档次

也就是假设一个ppi160，2寸x3寸的屏幕，物理像素应该是320x480。同理ppi320，同样尺寸的屏幕，物理像素是640x960

由于它们尺寸一致，假设它们观看距离一致，那么消除掉ppi的影响，他们的逻辑像素是一致的

也就是

逻辑像素长度 = 物理像素长度 * 160 / ppi

得出都是 320 x 480

当然，由于生产标准不一致，不可能做到绝对的160ppi作为标准，所以ppi的等级划分是动态的

#### dpr （device point ratio / device pixel ratio）

渲染像素与逻辑像素的比例。由于渲染像素一般等于逻辑像素，如果ppi是以160为基准的话，那么 dpr = ppi / 160

多少倍屏或者多少x（三倍屏，3x，意思就是3dpr），一般来说就是说的是这个值

#### viewport像素

它本质是DIP（Device Independent Pixels），中文意思设备无关像素，是与上述所有像素都无绝对逻辑关系的一个单位。其实是浏览器内部对逻辑像素进行再处理的结果，简单来理解就是调整逻辑像素的缩放来达到适应设备的一个中间层对于pc，viewport是不生效的，所以在pc上，px其实就是逻辑像素（chrome）。但是逻辑像素是与软件实现有关的，所以会出现一些问题。比如在win上，对于部分国产马甲浏览器，viewport内部没有适配系统的缩放等级，导致渲染的内容过小。

## 面向逻辑像素

1. 在head 设置width=device-width的viewport

2. 在css中使用px

3. 在适当的场景使用flex布局，或者配合vw进行自适应

4. 在**跨设备类型的时候**（pc <-> 手机 <-> 平板）使用媒体查询

5. 在跨设备类型如果交互差异太大的情况，考虑分开项目开发

viewport width=device-width是让viewport的尺寸等于**逻辑像素**的尺寸

### 盒子模型调整样式

- **Margin(外边距)** - 清除边框外的区域，外边距是透明的。

- **Border(边框)** - 围绕在内边距和内容外的边框。

- **Padding(内边距)** - 清除内容周围的区域，内边距是透明的。

- **Content(内容)** - 盒子的内容，显示文本和图像。

  #### box-sizing属性

  ```
  box-sizing: content-box|border-box|inherit;
  ```

  border-box ： width 和 height 属性包括内容，内边距和边框，但不包括外边距。

  content-box ：只包含width和height。

  inherit ：从父元素继承。

### 流式布局

宽度百分比自适应。

### float布局

左边float: left, 右边float: right。

### flex布局(非常好用)

Flex 布局是轴线布局，只能指定"项目"针对轴线的位置，可以看作是一维布局。

#### 布局容器

元素设置了**display: flex;**该元素就是容器。

##### 容器属性：

###### flex-direction 属性

```css
.faBox {
  flex-direction: 
      row 横向 | 
      row-reverse | 
      column 纵向| 
      column-reverse | 
      initial 最初的| 
      inherit 继承父元素属性;
}
```

###### flex-wrap 属性

```css
.faBox{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
```

###### flex-flow 属性

该属性是 `flex-wrap` 和 `flex-direction` 的简写方式。

```css
.faBox{
  flex-flow: <flex-direction> || <flex-wrap>;
}
```

###### justify-content 属性

该属性负责主轴的对齐方式。

```css
.faBox{
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

###### align-items 属性

该属性负责交叉轴的对齐方式。(单行)

```css
.faBox{
  justify-content: flex-start | flex-end | center | stretch | baseline;
}
```

###### align-content 属性

设置多根主轴时候的对齐方式，如果只有一条轴线，不起作用。（多行）

```css
.faBox{
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

#### 项目

容器里面的每项

##### 项目属性

###### order 属性

`order` 英文意思秩序，该属性可以设置项目的排列顺序，从小到大。

```css
.sonBox1{
    order: <integer>;
}
```

###### flex-grow 属性

定义项目的放大比例，默认 `0` ，不参与放大。

```css
.sonBox1{
   flex-grow: <number>; /* default 0 */
}
```

###### flex-shrink 属性

定义项目缩放。

```css
.sonBox1{
   flex-shrink: <number>; /* default 1 */
}
```

###### flex-basis 属性

属性定义了在分配多余空间之前，项目占据的主轴空间。

```css
.sonBox1{
   flex-shrink: <number>; /* default 1 */
}
```

###### flex 属性（推荐）

`flex-grow`，`flex-shrink` 和 `flex-basis` 的简写。

```css
.sonBox1{
   flex: none | [ <'flex-grow'> <'flex-shrink'> || <'flex-basis'> ]
}
```

###### align-self 属性

可给子元素设置单独的对齐方式。`auto` 的时候是继承父元素的 `align-item`

```css
.sonBox1{
   align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```

### vw、vh

视口单位，根据浏览器窗口大小单位进行自适应。

vw可视窗口的宽度单位，1vw = 可视窗口宽度的百分之一，width=1800px，1vw=18px。和百分比不一样的是，vw始终相对于可视窗口的宽度，而百分比和其父元素的宽度有关。

vh就是可视窗口的高度的单位。

vmin：选vw和vh中最小。

vmax：选vw和vh中最大。

### clac函数

calc() 函数用于动态计算长度值。

   ● 需要注意的是，运算符前后都需要保留一个空格，例如：width: calc(100% - 10px)；

   ● 任何长度值都可以使用calc()函数进行计算；（vw\vh\百分比\px等）

   ● calc()函数支持 "+", "-", "*", "/" 运算；

   ● calc()函数使用标准的数学运算优先级规则；

```css
width: calc(100% - 100px);
width: calc(100%/3 - 5px);
width: calc(5px*3 /2);
width: calc(100vw -50px);
...
```

## rem+flexible

已停止更新，只是等比缩放大小

## 小程序rpx

同上

## Grid网格布局

Grid 布局则是将容器划分成"行"和"列"，产生单元格，然后指定"项目所在"的单元格，可以看作是二维布局。

### 基本概念

```html
<div>
  <div><p>1</p></div>
  <div><p>2</p></div>
  <div><p>3</p></div>
</div>
```

容器和项目：采用网格布局的区域，称为"容器"（container）。容器内部采用网格定位的子元素，称为"项目"（item）；最外层的`<div>`元素就是容器，内层的三个`<div>`元素就是项目。注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的`<p>`元素就不是项目。Grid 布局只对项目生效。

行和列：容器里面的水平区域称为"行"（row），垂直区域称为"列"（column）

单元格：行和列交叉区域为单元格 (cell)。正常情况下，`n`行和`m`列会产生`n x m`个单元格。比如，3行3列会产生9个单元格。

网格线：划分网格的线（grid line），水平网格线划分出行，垂直网格线划分出列。正常情况下，`n`行有`n + 1`根水平网格线，`m`列有`m + 1`根垂直网格线，比如三行就有四根水平网格线。

### 容器属性

#### display属性

```html
div {
  display: grid;
}

div {
  display: inline-grid;
}
// 默认情况下，容器元素都是块级元素，但也可以设成行内元素。
```

注意，设为网格布局以后，容器子元素（项目）的`float`、`display: inline-block`、`display: table-cell`、`vertical-align`和`column-*`等设置都将失效。

#### grid-template-columns 属性， grid-template-rows 属性

容器指定了网格布局以后，接着就要划分行和列。`grid-template-columns`属性定义每一列的列宽，`grid-template-rows`属性定义每一行的行高。

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
}
// 指定了一个三行三列的网格，列宽和行高都是100px。
```

```css
.container {
  display: grid;
  grid-template-columns: 33.33% 33.33% 33.33%;
  grid-template-rows: 33.33% 33.33% 33.33%;
}
// 可以绝对值，也可以百分比
```

##### **（1）repeat()**

可以使用`repeat()`函数，简化重复的值。

```css
.container {
  display: grid;
  grid-template-columns: repeat(3, 33.33%); // grid-template-columns: 33.33% 33.33% 33.33%;
  grid-template-rows: repeat(3, 33.33%);
}
```

`repeat()`接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。

`repeat()`重复某种模式也是可以的。

```css
grid-template-columns: repeat(2, 100px 20px 80px); // 6列
grid-template-rows: repeat(2, 100px); // 2行
```

##### **（2）auto-fill 关键字**

有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用`auto-fill`关键字表示自动填充。

```css
.container {
  display: grid;
  grid-template-columns: repeat(auto-fill, 100px);
  grid-template-rows: repeat(1, 100px);
}
// 表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。
```

##### **（3）fr 关键字**

为了方便表示比例关系，网格布局提供了`fr`关键字（fraction 的缩写，意为"片段"）。如果两列的宽度分别为`1fr`和`2fr`，就表示后者是前者的两倍。

```css
.container {
  display: grid;
  grid-template-columns: 1fr 1fr;
}
```

`fr`可以与绝对长度的单位结合使用，这时会非常方便。

```css
.container {
  display: grid;
  grid-template-columns: 150px 1fr 2fr; // 剩下的按1：2分
}
```

##### **（4）minmax()**

`minmax()`函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。

```css
grid-template-columns: 1fr 1fr minmax(100px, 1fr); // minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。
```

##### **（5）auto 关键字**

`auto`关键字表示由浏览器自己决定长度。

```css
grid-template-columns: 100px auto 100px;
// 第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。
```

##### **（6）网格线的名称**

`grid-template-columns`属性和`grid-template-rows`属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。

```css
.container {
  display: grid;
  grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4];
  grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];
}
```

上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。

网格布局允许同一根线有多个名字，比如`[fifth-line row-5]`。

#### grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性

`grid-row-gap`属性设置行与行的间隔（行间距），`grid-column-gap`属性设置列与列的间隔（列间距）。

```css
.container {
  grid-row-gap: 20px;
  grid-column-gap: 20px;
}
```

`grid-gap`属性是`grid-column-gap`和`grid-row-gap`的合并简写形式

```css
.container {
  grid-gap: 20px 20px; // 或 gap: 20px;
}
// grid-gap: <grid-row-gap> <grid-column-gap>;
```

根据最新标准，上面三个属性名的`grid-`前缀已经删除，`grid-column-gap`和`grid-row-gap`写成`column-gap`和`row-gap`，`grid-gap`写成`gap`。

#### grid-template-areas 属性

网格布局允许指定"区域"（area），一个区域由单个或多个单元格组成。`grid-template-areas`属性用于定义区域。

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-template-areas: 'a b c'
                       'd e f'
                       'g h i';
}
```

上面代码先划分出9个单元格，然后将其定名为`a`到`i`的九个区域，分别对应这九个单元格。

多个单元格合并成一个区域的写法如下。

```css
grid-template-areas: 'a a a'
                     'b b b'
                     'c c c';
```

上面代码将9个单元格分成`a`、`b`、`c`三个区域。

下面是一个布局实例。

```css
grid-template-areas: "header header header"
                     "main main sidebar"
                     "footer footer footer";
```

上面代码中，顶部是页眉区域`header`，底部是页脚区域`footer`，中间部分则为`main`和`sidebar`。

如果某些区域不需要利用，则使用"点"（`.`）表示。

```css
grid-template-areas: 'a . c'
                     'd . f'
                     'g . i';
```

上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。

注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为`区域名-start`，终止网格线自动命名为`区域名-end`。

比如，区域名为`header`，则起始位置的水平网格线和垂直网格线叫做`header-start`，终止位置的水平网格线和垂直网格线叫做`header-end`。

#### grid-auto-flow 属性

划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行，即下图数字的顺序。

```css
grid-auto-flow: row;    // 先行后列
grid-auto-flow: column; // 先列后行

grid-auto-flow: row dense; // 先行后列,并且尽可能紧密填满，尽量不出现空格。
grid-auto-flow: column dense; // 先列后行,并且尽可能紧密填满，尽量不出现空格。
```

#### justify-items 属性， align-items 属性， place-items 属性

`justify-items`属性设置单元格内容的水平位置（左中右），`align-items`属性设置单元格内容的垂直位置（上中下）。

```css
.container {
  justify-items: start | end | center | stretch;
  align-items: start | end | center | stretch;
}
```

`place-items`属性是`align-items`属性和`justify-items`属性的合并简写形式。

```css
place-items: <align-items> <justify-items>;
```

#### justify-content 属性， align-content 属性， place-content 属性

`justify-content`属性是整个内容区域在容器里面的水平位置（左中右），`align-content`属性是整个内容区域的垂直位置（上中下）。

```css
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}
// start - 对齐容器的起始边框。
// end - 对齐容器的结束边框。
// center - 容器内部居中。
// stretch - 项目大小没有指定时，拉伸占据整个网格容器。
// space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。
// space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。
// space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。
```

`place-content`属性是`align-content`属性和`justify-content`属性的合并简写形式。

```css
place-content: <align-content> <justify-content>
```

#### grid-auto-columns 属性， grid-auto-rows 属性