# vue技巧

## this.$set(obj,key,value)

```js
// data
{
    person: { // 个人信息
        name: '',
        age: '',
        gender: ''
    }
}

// 作为接口参数传递
ajax(this.person)

// 接口获取数据，批量处理
ajax().then(res => {
 const {name, age, gender} = res.data
    this.$set(this, 'person', {name, age, gender})
})
```

## 策略模式

策略模式的使用，避免过多的if else判断，也可以替代简单逻辑的switch

```js
const formatDemandItemType = (value) => {
    switch (value) {
        case 1:
            return '基础'
        case 2:
            return '高级'
        case 3:
            return 'VIP'
    }
}

// 策略模式
const formatDemandItemType2 = (value) => {
    const obj = {
        1: '基础',
        2: '高级',
        3: 'VIP',
    }
    
    return obj[value]
}
```

## 职责单一

任何时候尽量是的一个函数就做一件事情，而不是将各种逻辑全部耦合在一起，提高单个函数的复用性和可读性
每个页面都会在加载完成时进行数据的请求并展示到页面

```js
created() {
  this.init();
},
methods: {
  // 将全部的请求行为聚合在init函数中
  // 将每个请求单独拆分
  init() {
    this.getList1()
    this.getList2()
  },
  getList1() {
    // to do ...
  },
  getList2() {
    // to do ...
  }
}
```

## 冻结渲染无关的数据

vue中data的数据默认便会进行双向数据绑定，若是将大量的和渲染无关的数据直接放置在data中，将会浪费双向数据绑定时所消耗的性能，将这些和渲染无关的数据进行抽离并配合Object.freeze进行处理
table中columns数据可以单独提取一个外部js文件作为配置文件，也可以在当前.vue文件中定义一个常量定义columns数据，因为无论如何都是固定且不会修改的数据，应该使用Object.freeze进行包裹，既可以提高性能还可以将固定的数据抽离，一些下拉框前端固定的数据也建议此操作

```js
const columnList = Object.freeze([
  { title: '姓名', key: 'name', align: 'center' },
  { title: '性别', key: 'gender', align: 'center' }
])
```

::: tip

需要注意的是 Object.freeze() 冻结的是值，这时仍然可以将变量的引用替换掉，还有确保数据不会变才可以使用这个语法，如果要对数据进行修改和交互，就不适合使用冻结了。

:::

## 样式穿透

在开发中修改第三方组件样式是很常见，但由于 scoped 属性的样式隔离，可能需要去除 scoped 或是另起一个 style 。这些做法都会带来副作用（组件样式污染、不够优雅），样式穿透在css预处理器中使用才生效。

- less使用  **/deep/**

  ```css
  <style scoped lang="less">
  .content /deep/ .el-button {
  	 height: 60px;
  }
  </style>
  ```

- scss使用 **::v-deep**

  ```css
  <style scoped lang="scss">
  .content ::v-deep .el-button {
    height: 60px;
  }
  </style>
  ```

- stylus使用 **>>>**

  ```css
  <style scoped ang="stylus">
  外层 >>> .custon-components{
    height: 60px;
  }
  </style>
  ```


## 子组件修改父组件

用到sync修饰符,语法糖

```js
// 父组件
<update-info v-if="updateInfoVisible" :isclosed.sync="updateInfoVisible" ref="updateInfo"></update-info>


updateInfoVisible： false

// 子组件
props: {
    isclosed: Boolean
}
handleClosed () {
   this.$emit('update:isclosed', false)
}

// 父组件通过属性传值，通过.sync修饰  :isclosed.sync="updateInfoVisible"
// 子组件通过props接收，通过 this.$emit('update:isclosed', false) 修改 
```



### 动态组件，让页面渲染更灵活

需要根据用户的权限不同，页面上要显示不同的内容;将不同权限对应的组件写了出来，然后再通过`v-if`来判断要显示哪个组件，就有了下面的代码

```vue
<template>
  <div class="info">
    <component :is="roleComponents" v-if="roleComponent" />
  </div>
</template>
<script>
import AdminInfo from './admin-info'
import BookkeeperInfo from './bookkeeper-info'
import HrInfo from './hr-info'
import UserInfo from './user-info'
export default {
  components: {
    AdminInfo,
    BookkeeperInfo,
    HrInfo,
    UserInfo
  },
  data() {
    return {
      roleComponents: {
        admin: AdminInfo,
        bookkeeper: BookkeeperInfo,
        hr: HrInfo,
        user: UserInfo
      },
      role: 'user',
      roleComponent: undefined
    }
  },
  created() {
    const { role, roleComponents } = this
    this.roleComponent = roleComponents[role]
  }
}
</script>
```



## minxins,组件内容的复用

mixins是Vue提供的一种混合机制，用来更高效的实现组件内容的复用。

在`Vue`中，一个混入对象可以包含任意组件选项，但是对于不同的组件选项，会有不同的合并策略。

1. `data` 对于`data`,在混入时会进行递归合并，如果两个属性发生冲突，则以组件自身为主，如上例中的`chart`属性。
2. 生命周期钩子函数，混入时会将同名钩子函数加入到一个数组中，然后在调用时依次执行。混入对象里面的钩子函数会优先于组件的钩子函数执行。如果一个组件混入了多个对象，对于混入对象里面的同名钩子函数，将按照数组顺序依次执行
3. 其他选项 对于值为对象的选项，如`methods`,`components`,`filter`,`directives`,`props`等等，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

### 示例

**textMixin.js**

```js
// 混入代码 resize-mixins.js
import { debounce } from 'lodash'
const resizeChartMethod = '$__resizeChartMethod'

export default {
  data() {
    // 在组件内部将图表init的引用映射到chart属性上
    return {
      chart: null
    }
  },
  created() {
    window.addEventListener('resize', this[resizeChartMethod])
  },
  beforeDestroy() {
    window.removeEventListener('reisze', this[resizeChartMethod])
  },
  methods: {
    // 通过lodash的防抖函数来控制resize的频率
    [resizeChartMethod]: debounce(function() {
      if (this.chart) {
        this.chart.resize()
      }
    }, 100)
  }
}
```

index.vue

```vue
<!--图表组件代码-->
<template>
  <div class="chart"></div>
</template>
<script>
import echartMixins from './echarts-mixins'
export default {
  // mixins属性用于导入混入，是一个数组，数组可以传入多个混入对象
  mixins: [echartMixins],
  data() {
    return {
      chart: null
    }
  },
  mounted() {
    this.chart = echarts.init(this.$el)
  }
}
</script>
```



### 全局混入

```
Vue.mixin({
  methods: {
    /**
     * 将埋点方法通过全局混入添加到每个组件内部
     * 
     * 建议将埋点方法绑定到Vue的原型链上面，如： Vue.prototype.$track = () => {}
     * */
    track(message) {
      console.log(message)
    }
  }
})
```

## Vue.use

Vue插件

```js
// 插件
const plugin = {
  install(){
    document.write('我是install内的代码')
  }
}

// 初始化插件
Vue.use(plugin); // 页面显示"我是install内的代码"

```

#### 总结

1. Vue的插件是一个**对象**, 就像`Element`.
2. 插件**对象**必须有`install`字段.
3. `install`字段是一个函数.
4. 初始化插件**对象**需要通过`Vue.use()`.

#### 扩展学习

1. `Vue.use()`调用必须在`new Vue`之前.
2. 同一个插件多次使用Vue.use()也只会被运行一次.

## Vue.prototype.$xx

在Vue实例上挂载一个方法/属性

原型链原理。



## vue组件使用方式

写好子组件

```vue
<template>
  <button class="btn" :style="{color:color}">
    <slot/> <!-- 插槽 -->
  </button>
</template>

<script>
export default {
  name: Button,
  // 传入子组件的参数写到props
  props: {
    color: {
      type: String, // 颜色参数类型
      default: "#000"  // 默认黑色
    }
  }
}
</script>

<style scoped>
  .btn {
    width: 110px;
    height: 60px;
    border-radius: 10px;
    border: none;
    font-size: 15px;
  }
</style>
```

### 普通组件

1. 引入组件
2. 在components中声明
3. 在template使用

```vue
<template>
  <div id="app">
    <!-- 3. 在模版语法中使用 -->
    <Button color="red">我是插槽的值</Button>
  </div>
</template>

<script>
// 1. 在页面种引用组件
import Button from '@/components/Button.vue'
  
export default {
  name: "app",
  // 2. 在components中声明组件
  components: {
    Button
  }
};
</script>
```

::: tip
一般公用组件放在component文件夹内，view同级（放置页面）
:::

### 全局组件-component

只能一个一个注册

```js
import Vue from 'vue'; 
// 引入Button组件 
import Button from './Button.vue'; 
// 将loading注册为全局组件，在别的组件中通过<Button>标签使用Loading组件 
Vue.component('Button', Button);
```

### 全局组件-插件

1. 子组建添加install方法
2. 在main.js中引用
3. 使用Vue.use（）方法
4. 在页面中使用

```js
// Button.js 

import ButtonComponent from './Button.vue'

// 1.添加install方法 （插件方法）
const Button = {
  install (Vue) {
    Vue.component("Button", ButtonComponent);
  }
}

// 导出Button
export default Button

```

::: tip
也可处理多个全局组件，install可以处理更多事情
:::

```js
// Button.js 

import ButtonComponent1 from './Button1.vue'
import ButtonComponent2 from './Button2.vue'
import ButtonComponent3 from './Button3.vue'

const buttonList = [
    ButtonComponent1,
    ButtonComponent2,
    ButtonComponent3
];
// 1.添加install方法 （插件方法）
const Button = {
  install (Vue，options) {
    buttonList.forEach(button=>{
        // 这里 使用每个组件的 name 属性作为组件名
        Vue.component(button.name, button);
    })
    
  // 更多事情
      // 添加全局方法或属性
  Vue.myGlobalMethod = function () {
    // 逻辑...
  }

  // 添加全局资源
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {
      // 逻辑...
    }
    ...
  })

  // 注入组件选项
  Vue.mixin({
    created: function () {
      // 逻辑...
    }
    ...
  })

  // 添加实例方法
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑...
  }
}

// 导出Button
export default Button
```

```js
// main.js

import Vue from 'vue'
import App from './App.vue'
// 2. 导入 
import Button from '@/components/Button.js'
// 3. 使用 必须在new Vue之前
Vue.use(Button);
new Vue({
  render: h => h(App),
}).$mount('#app')

```

```vue
// 4 任意页面，比如app.vue

<template>
  <div id="app">
    <!-- 5. 在页面上使用 -->
    <Button color="blue">我是全局按钮</Button>
  </div>
</template>
```

### 构造组件

1. Vue.extend 构建组件
2. 挂载到Vue.prototype
3. 在页面的script内使用

```js
// 1. 构建组件
import Vue from 'vue'
// 将复用的页面导入
import Comp from './index.vue'
// 构造组件
let Constructor = Vue.extend(Comp)
let instance
const CustomFieldSetting = {
    //options: {code:动态表code, max:最大勾选数, title:标题}, callback: 确定后的回调
    show (options, callback) {
        if (!instance) {
			// 创造实例，isntance就相当于vue的this
            instance = new Constructor({})
			// 渲染
            instance.$mount()
			// 挂载
            document.body.appendChild(instance.$el)
        }
        instance.init(options, callback)
        instance.visible = true
    }
}
export default CustomFieldSetting
```

```js
// 2.挂载到prototype
import Vue from 'vue'
import CustomFieldSetting from './custom-field-setting'

Vue.prototype.$CustomFieldSetting = CustomFieldSetting
```

```js
// 3.页面上使用
this.$CustomFieldSetting.show({...})
```

## 二次封装组件

::: tip
`$attrs`: 当组件在调用时传入的属性没有在`props`里面定义时，传入的属性将被绑定到`$attrs`属性内（`class`与`style`除外，他们会挂载到组件最外层元素上）。并可通过`v-bind="$attrs"`传入到内部组件中。
:::

::: tip
`$listeners`: 当组件被调用时，外部监听的这个组件的所有事件都可以通过`$listeners`获取到。并可通过`v-on="$listeners"`传入到内部组件中。
:::

### 比如二次封装el-dialog

#### 定义基本弹框代码

```vue
<template>
  <el-dialog :visible.sync="visibleDialog">
    <!--内容区域的默认插槽-->
    <slot></slot>
    <!--使用弹框的footer插槽添加按钮-->
    <template #footer>
      <!--对外继续暴露footer插槽，有个别弹框按钮需要自定义-->
      <slot name="footer">
        <!--将取消与确定按钮集成到内部-->
        <span>
          <el-button @click="$_handleCancel">取 消</el-button>
          <el-button type="primary" @click="$_handleConfirm">
            确 定
          </el-button>
        </span>
      </slot>
    </template>
  </el-dialog>
</template>
<script>
export default {
  props: {
    // 对外暴露visible属性，用于显示隐藏弹框
    visible: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    // 通过计算属性，对.sync进行转换，外部也可以直接使用visible.sync
    visibleDialog: {
      get() {
        return this.visible;
      },
      set() {
        this.$emit("update:visible");
      }
    }
  },
  methods: {
    // 对外抛出cancel事件
    $_handleCancel() {
      this.$emit("cancel");
    },
    // 对外抛出 confirm事件
    $_handleConfirm() {
      this.$emit("confirm");
    }
  }
}
</script>
```

#### 使用二次组件

```vue
<!--外部使用方式 confirm cancel 是自定义的事件 opened是包装el-dialog的事件，通过$listeners传入到el-dialog里面-->
<custom-dialog :visible.sync="visibleDialog" @opened="$_handleOpened" @confirm="$_handleConfirm" @cancel="$_handleCancel">这是一段内容</custom-dialog>
```

但上面的代码存在一个问题，无法将Dialog自身的属性和事件暴露到外部（虽然可以通过props及$emit一个一个添加，但是很麻烦）,这时候就可以使用$attrs与$listeners

#### 使用`$attrs`与`$listeners`

```vue
<!---使用了v-bind与v-on监听属性与事件-->
<template>
    <el-dialog :visible.sync="visibleDialog" v-bind="$attrs" v-on="$listeners">
    <!--其他代码不变-->
    </el-dialog>
</template>
<script>
  export default {
    //默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 
    //将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。
    //通过设置 inheritAttrs 到 false，这些默认行为将会被去掉
    inheritAttrs: false
 }
</script>

<!---外部使用方式-->
<custom-dialog
  :visible.sync="visibleDialog"
  title="测试弹框"
  @opened="$_handleOpened"
>
  这是一段内容
</custom-dialog>
```

#### 对于`$attrs`，也可以使用`$props`来代替

```vue
<template>
  <el-dialog :visible.sync="visibleDialog" v-bind="$props" v-on="$listeners">
    <!--其他代码不变-->
  </el-dialog>
</template>
<script>
import { Dialog } from 'element-ui'
export default {
  props: {
    // 将Dialog的props通过扩展运算符展开到props属性里面
    ...Dialog.props
  }
}
</script>
```

但上面的代码存在一定的缺陷，有些组件存在非`props`的属性，比如对于一些封装的表单组件，我们可能需要给组件传入原生属性，但实际原生属性并没有在组件的`props`上面定义，这时候，如果通过上面的方式去包装组件，那么这些原生组件将无法传递到内部组件里面。

## 使用`require.context`实现前端工程自动化

