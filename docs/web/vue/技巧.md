# vue技巧

## this.$set(obj,key,value)

```js
// data
{
    person: { // 个人信息
        name: '',
        age: '',
        gender: ''
    }
}

// 作为接口参数传递
ajax(this.person)

// 接口获取数据，批量处理
ajax().then(res => {
 const {name, age, gender} = res.data
    this.$set(this, 'person', {name, age, gender})
})
```

## 策略模式

策略模式的使用，避免过多的if else判断，也可以替代简单逻辑的switch

```js
const formatDemandItemType = (value) => {
    switch (value) {
        case 1:
            return '基础'
        case 2:
            return '高级'
        case 3:
            return 'VIP'
    }
}

// 策略模式
const formatDemandItemType2 = (value) => {
    const obj = {
        1: '基础',
        2: '高级',
        3: 'VIP',
    }
    
    return obj[value]
}
```

## 职责单一

任何时候尽量是的一个函数就做一件事情，而不是将各种逻辑全部耦合在一起，提高单个函数的复用性和可读性
每个页面都会在加载完成时进行数据的请求并展示到页面

```js
created() {
  this.init();
},
methods: {
  // 将全部的请求行为聚合在init函数中
  // 将每个请求单独拆分
  init() {
    this.getList1()
    this.getList2()
  },
  getList1() {
    // to do ...
  },
  getList2() {
    // to do ...
  }
}
```

## 冻结渲染无关的数据

vue中data的数据默认便会进行双向数据绑定，若是将大量的和渲染无关的数据直接放置在data中，将会浪费双向数据绑定时所消耗的性能，将这些和渲染无关的数据进行抽离并配合Object.freeze进行处理
table中columns数据可以单独提取一个外部js文件作为配置文件，也可以在当前.vue文件中定义一个常量定义columns数据，因为无论如何都是固定且不会修改的数据，应该使用Object.freeze进行包裹，既可以提高性能还可以将固定的数据抽离，一些下拉框前端固定的数据也建议此操作

```js
const columnList = Object.freeze([
  { title: '姓名', key: 'name', align: 'center' },
  { title: '性别', key: 'gender', align: 'center' }
])
```

::: tip

需要注意的是 Object.freeze() 冻结的是值，这时仍然可以将变量的引用替换掉，还有确保数据不会变才可以使用这个语法，如果要对数据进行修改和交互，就不适合使用冻结了。

:::

## 样式穿透

在开发中修改第三方组件样式是很常见，但由于 scoped 属性的样式隔离，可能需要去除 scoped 或是另起一个 style 。这些做法都会带来副作用（组件样式污染、不够优雅），样式穿透在css预处理器中使用才生效。

- less使用  **/deep/**

  ```css
  <style scoped lang="less">
  .content /deep/ .el-button {
  	 height: 60px;
  }
  </style>
  ```

- scss使用 **::v-deep**

  ```css
  <style scoped lang="scss">
  .content ::v-deep .el-button {
    height: 60px;
  }
  </style>
  ```

- stylus使用 **>>>**

  ```css
  <style scoped ang="stylus">
  外层 >>> .custon-components{
    height: 60px;
  }
  </style>
  ```


## 子组件修改父组件

用到sync修饰符,语法糖

```js
// 父组件
<update-info v-if="updateInfoVisible" :isclosed.sync="updateInfoVisible" ref="updateInfo"></update-info>


updateInfoVisible： false

// 子组件
props: {
    isclosed: Boolean
}
handleClosed () {
   this.$emit('update:isclosed', false)
}

// 父组件通过属性传值，通过.sync修饰  :isclosed.sync="updateInfoVisible"
// 子组件通过props接收，通过 this.$emit('update:isclosed', false) 修改 
```

## minxins

mixins是Vue提供的一种混合机制，用来更高效的实现组件内容的复用。

在`Vue`中，一个混入对象可以包含任意组件选项，但是对于不同的组件选项，会有不同的合并策略。

1. `data` 对于`data`,在混入时会进行递归合并，如果两个属性发生冲突，则以组件自身为主，如上例中的`chart`属性。
2. 生命周期钩子函数，混入时会将同名钩子函数加入到一个数组中，然后在调用时依次执行。混入对象里面的钩子函数会优先于组件的钩子函数执行。如果一个组件混入了多个对象，对于混入对象里面的同名钩子函数，将按照数组顺序依次执行
3. 其他选项 对于值为对象的选项，如`methods`,`components`,`filter`,`directives`,`props`等等，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

### 示例

**textMixin.js**

```js
export default {
  data () {
    return {}
  },
  created () {

  },
  methods: {
    textHandle () {
      console.log(111)
    }
  }
}
```

**index.js**

```js
import textMixinfrom '@/mixins/textMixin'
export default {
   mixins: [tableMixin],
     created () { this.textHandle() }

}
// 111
```



### 全局混入

```
Vue.mixin({
  methods: {
    /**
     * 将埋点方法通过全局混入添加到每个组件内部
     * 
     * 建议将埋点方法绑定到Vue的原型链上面，如： Vue.prototype.$track = () => {}
     * */
    track(message) {
      console.log(message)
    }
  }
})
```

## Vue.use

Vue插件

```js
// 插件
const plugin = {
  install(){
    document.write('我是install内的代码')
  }
}

// 初始化插件
Vue.use(plugin); // 页面显示"我是install内的代码"

```

#### 总结

1. Vue的插件是一个**对象**, 就像`Element`.
2. 插件**对象**必须有`install`字段.
3. `install`字段是一个函数.
4. 初始化插件**对象**需要通过`Vue.use()`.

#### 扩展学习

1. `Vue.use()`调用必须在`new Vue`之前.
2. 同一个插件多次使用Vue.use()也只会被运行一次.

## Vue.prototype.$xx

在Vue实例上挂载一个方法/属性

原型链原理。



## vue组件使用方式

写好子组件

```vue
<template>
  <button class="btn" :style="{color:color}">
    <slot/> <!-- 插槽 -->
  </button>
</template>

<script>
export default {
  name: Button,
  // 传入子组件的参数写到props
  props: {
    color: {
      type: String, // 颜色参数类型
      default: "#000"  // 默认黑色
    }
  }
}
</script>

<style scoped>
  .btn {
    width: 110px;
    height: 60px;
    border-radius: 10px;
    border: none;
    font-size: 15px;
  }
</style>
```

### 普通组件

1. 引入组件
2. 在components中声明
3. 在template使用

```vue
<template>
  <div id="app">
    <!-- 3. 在模版语法中使用 -->
    <Button color="red">我是插槽的值</Button>
  </div>
</template>

<script>
// 1. 在页面种引用组件
import Button from '@/components/Button.vue'
  
export default {
  name: "app",
  // 2. 在components中声明组件
  components: {
    Button
  }
};
</script>
```

::: tip
一般公用组件放在component文件夹内，view同级（放置页面）
:::

### 全局组件-component

只能一个一个注册

```js
import Vue from 'vue'; 
// 引入Button组件 
import Button from './Button.vue'; 
// 将loading注册为全局组件，在别的组件中通过<Button>标签使用Loading组件 
Vue.component('Button', Button);
```

### 全局组件-插件

1. 子组建添加install方法
2. 在main.js中引用
3. 使用Vue.use（）方法
4. 在页面中使用

```js
// Button.js 

import ButtonComponent from './Button.vue'

// 1.添加install方法 （插件方法）
const Button = {
  install (Vue) {
    Vue.component("Button", ButtonComponent);
  }
}

// 导出Button
export default Button

```

::: tip
也可处理多个全局组件，install可以处理更多事情
:::

```js
// Button.js 

import ButtonComponent1 from './Button1.vue'
import ButtonComponent2 from './Button2.vue'
import ButtonComponent3 from './Button3.vue'

const buttonList = [
    ButtonComponent1,
    ButtonComponent2,
    ButtonComponent3
];
// 1.添加install方法 （插件方法）
const Button = {
  install (Vue，options) {
    buttonList.forEach(button=>{
        // 这里 使用每个组件的 name 属性作为组件名
        Vue.component(button.name, button);
    })
    
  // 更多事情
      // 添加全局方法或属性
  Vue.myGlobalMethod = function () {
    // 逻辑...
  }

  // 添加全局资源
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {
      // 逻辑...
    }
    ...
  })

  // 注入组件选项
  Vue.mixin({
    created: function () {
      // 逻辑...
    }
    ...
  })

  // 添加实例方法
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑...
  }
}

// 导出Button
export default Button
```

```js
// main.js

import Vue from 'vue'
import App from './App.vue'
// 2. 导入 
import Button from '@/components/Button.js'
// 3. 使用 必须在new Vue之前
Vue.use(Button);
new Vue({
  render: h => h(App),
}).$mount('#app')

```

```vue
// 4 任意页面，比如app.vue

<template>
  <div id="app">
    <!-- 5. 在页面上使用 -->
    <Button color="blue">我是全局按钮</Button>
  </div>
</template>
```

### 构造组件

1. Vue.extend 构建组件
2. 挂载到Vue.prototype
3. 在页面的script内使用

