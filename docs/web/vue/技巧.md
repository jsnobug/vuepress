# vue技巧

## this.$set(obj,key,value)

```js
// data
{
    person: { // 个人信息
        name: '',
        age: '',
        gender: ''
    }
}

// 作为接口参数传递
ajax(this.person)

// 接口获取数据，批量处理
ajax().then(res => {
 const {name, age, gender} = res.data
    this.$set(this, 'person', {name, age, gender})
})
```

## 策略模式

策略模式的使用，避免过多的if else判断，也可以替代简单逻辑的switch

```js
const formatDemandItemType = (value) => {
    switch (value) {
        case 1:
            return '基础'
        case 2:
            return '高级'
        case 3:
            return 'VIP'
    }
}

// 策略模式
const formatDemandItemType2 = (value) => {
    const obj = {
        1: '基础',
        2: '高级',
        3: 'VIP',
    }
    
    return obj[value]
}
```

## 职责单一

任何时候尽量是的一个函数就做一件事情，而不是将各种逻辑全部耦合在一起，提高单个函数的复用性和可读性
每个页面都会在加载完成时进行数据的请求并展示到页面

```js
created() {
  this.init();
},
methods: {
  // 将全部的请求行为聚合在init函数中
  // 将每个请求单独拆分
  init() {
    this.getList1()
    this.getList2()
  },
  getList1() {
    // to do ...
  },
  getList2() {
    // to do ...
  }
}
```

## 冻结渲染无关的数据

vue中data的数据默认便会进行双向数据绑定，若是将大量的和渲染无关的数据直接放置在data中，将会浪费双向数据绑定时所消耗的性能，将这些和渲染无关的数据进行抽离并配合Object.freeze进行处理
table中columns数据可以单独提取一个外部js文件作为配置文件，也可以在当前.vue文件中定义一个常量定义columns数据，因为无论如何都是固定且不会修改的数据，应该使用Object.freeze进行包裹，既可以提高性能还可以将固定的数据抽离，一些下拉框前端固定的数据也建议此操作

```js
const columnList = Object.freeze([
  { title: '姓名', key: 'name', align: 'center' },
  { title: '性别', key: 'gender', align: 'center' }
])
```

::: tip

需要注意的是 Object.freeze() 冻结的是值，这时仍然可以将变量的引用替换掉，还有确保数据不会变才可以使用这个语法，如果要对数据进行修改和交互，就不适合使用冻结了。

:::

## vue通讯方式总结

### ref传递

### props和$emit

### .sync和v-model语法糖

### v-bind=$props v-bind=$attrs v-on=$listener

### evenbus

### vuex 

### solt

## 样式穿透

在开发中修改第三方组件样式是很常见，但由于 scoped 属性的样式隔离，可能需要去除 scoped 或是另起一个 style 。这些做法都会带来副作用（组件样式污染、不够优雅），样式穿透在css预处理器中使用才生效。

- less使用  **/deep/**

  ```css
  <style scoped lang="less">
  .content /deep/ .el-button {
  	 height: 60px;
  }
  </style>
  ```

- scss使用 **::v-deep**

  ```css
  <style scoped lang="scss">
  .content ::v-deep .el-button {
    height: 60px;
  }
  </style>
  ```

- stylus使用 **>>>**

  ```css
  <style scoped ang="stylus">
  外层 >>> .custon-components{
    height: 60px;
  }
  </style>
  ```


## .sync,子组件修改父组件

用到sync修饰符,语法糖

```js
// 父组件
<update-info v-if="updateInfoVisible" :isclosed.sync="updateInfoVisible" ref="updateInfo"></update-info>


updateInfoVisible： false

// 子组件
props: {
    isclosed: Boolean
}
handleClosed () {
   this.$emit('update:isclosed', false)
}

// 父组件通过属性传值，通过.sync修饰  :isclosed.sync="updateInfoVisible"
// 子组件通过props接收，通过 this.$emit('update:isclosed', false) 修改 
```



## 动态组件，让页面渲染更灵活

需要根据用户的权限不同，页面上要显示不同的内容;将不同权限对应的组件写了出来，然后再通过`v-if`来判断要显示哪个组件，就有了下面的代码

```vue
<template>
    <div class="statistics-dp">
      <!--头部-->
      <dp-header :title="title" :text="'测试'" @to-module="toModule"></dp-header>
      <!--内容-->
      <component :is="currentView"/>
    </div>
</template>

<script>
  import dpHeader from './dp-header'
  import defaultView from './module/default-view'
  import deviceView from './module/device-view'

  export default {
    components: {
      dpHeader,
      defaultView,
      deviceView
    },
    name: 'index',
    data () {
      return {
        title: '',
        index: 1,
        componentList: ['defaultView', 'deviceView']
      }
    },
    created () {
      this.title = JSON.parse(window.localStorage.getItem('companyList'))[0].name
    },
    destroyed () {
      console.log('大屏主体注销了')
    },
    computed: {
      currentView () {
        if (this.componentList.length - 1 < this.index) {
          return this.componentList[0]
        } else {
          return this.componentList[this.index]
        }
      }
    },
    methods: {
      toModule (index) {
        this.index = index
      }
    }
  }
</script>

<style lang="scss">
  .statistics-dp {
    height: 100vh;
    width: 100%;
    overflow: hidden;
    background-image: radial-gradient(circle, #0074CB -100%, #000823 60%);
    div,ul,li,span{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      list-style: none;
    }
  }
</style>
```

```vue
<template>
  <div class="info">
    <component :is="roleComponents" v-if="roleComponent" />
  </div>
</template>
<script>
import AdminInfo from './admin-info'
import BookkeeperInfo from './bookkeeper-info'
import HrInfo from './hr-info'
import UserInfo from './user-info'
export default {
  components: {
    AdminInfo,
    BookkeeperInfo,
    HrInfo,
    UserInfo
  },
  data() {
    return {
      roleComponents: {
        admin: AdminInfo,
        bookkeeper: BookkeeperInfo,
        hr: HrInfo,
        user: UserInfo
      },
      role: 'user',
      roleComponent: undefined
    }
  },
  created() {
    const { role, roleComponents } = this
    this.roleComponent = roleComponents[role]
  }
}
</script>
```



## minxins,组件内容的复用

mixins是Vue提供的一种混合机制，用来更高效的实现组件内容的复用。

在`Vue`中，一个混入对象可以包含任意组件选项，但是对于不同的组件选项，会有不同的合并策略。

1. `data` 对于`data`,在混入时会进行递归合并，如果两个属性发生冲突，则以组件自身为主，如上例中的`chart`属性。
2. 生命周期钩子函数，混入时会将同名钩子函数加入到一个数组中，然后在调用时依次执行。混入对象里面的钩子函数会优先于组件的钩子函数执行。如果一个组件混入了多个对象，对于混入对象里面的同名钩子函数，将按照数组顺序依次执行
3. 其他选项 对于值为对象的选项，如`methods`,`components`,`filter`,`directives`,`props`等等，将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。

### 示例

**textMixin.js**

```js
// 混入代码 resize-mixins.js
import { debounce } from 'lodash'
const resizeChartMethod = '$__resizeChartMethod'

export default {
  data() {
    // 在组件内部将图表init的引用映射到chart属性上
    return {
      chart: null
    }
  },
  created() {
    window.addEventListener('resize', this[resizeChartMethod])
  },
  beforeDestroy() {
    window.removeEventListener('reisze', this[resizeChartMethod])
  },
  methods: {
    // 通过lodash的防抖函数来控制resize的频率
    [resizeChartMethod]: debounce(function() {
      if (this.chart) {
        this.chart.resize()
      }
    }, 100)
  }
}
```

index.vue

```vue
<!--图表组件代码-->
<template>
  <div class="chart"></div>
</template>
<script>
import echartMixins from './echarts-mixins'
export default {
  // mixins属性用于导入混入，是一个数组，数组可以传入多个混入对象
  mixins: [echartMixins],
  data() {
    return {
      chart: null
    }
  },
  mounted() {
    this.chart = echarts.init(this.$el)
  }
}
</script>
```



### 全局混入

```
Vue.mixin({
  methods: {
    /**
     * 将埋点方法通过全局混入添加到每个组件内部
     * 
     * 建议将埋点方法绑定到Vue的原型链上面，如： Vue.prototype.$track = () => {}
     * */
    track(message) {
      console.log(message)
    }
  }
})
```

## Vue.use

Vue插件

```js
// 插件
const plugin = {
  install(){
    document.write('我是install内的代码')
  }
}

// 初始化插件
Vue.use(plugin); // 页面显示"我是install内的代码"

```

#### 总结

1. Vue的插件是一个**对象**, 就像`Element`.
2. 插件**对象**必须有`install`字段.
3. `install`字段是一个函数.
4. 初始化插件**对象**需要通过`Vue.use()`.

#### 扩展学习

1. `Vue.use()`调用必须在`new Vue`之前.
2. 同一个插件多次使用Vue.use()也只会被运行一次.

## Vue.prototype.$xx

在Vue实例上挂载一个方法/属性

原型链原理。



## vue组件使用方式

写好子组件

```vue
<template>
  <button class="btn" :style="{color:color}">
    <slot/> <!-- 插槽 -->
  </button>
</template>

<script>
export default {
  name: Button,
  // 传入子组件的参数写到props
  props: {
    color: {
      type: String, // 颜色参数类型
      default: "#000"  // 默认黑色
    }
  }
}
</script>

<style scoped>
  .btn {
    width: 110px;
    height: 60px;
    border-radius: 10px;
    border: none;
    font-size: 15px;
  }
</style>
```

### 普通组件

1. 引入组件
2. 在components中声明
3. 在template使用

```vue
<template>
  <div id="app">
    <!-- 3. 在模版语法中使用 -->
    <Button color="red">我是插槽的值</Button>
  </div>
</template>

<script>
// 1. 在页面种引用组件
import Button from '@/components/Button.vue'
  
export default {
  name: "app",
  // 2. 在components中声明组件
  components: {
    Button
  }
};
</script>
```

::: tip
一般公用组件放在component文件夹内，view同级（放置页面）
:::

### 全局组件-component

只能一个一个注册

```js
import Vue from 'vue'; 
// 引入Button组件 
import Button from './Button.vue'; 
// 将loading注册为全局组件，在别的组件中通过<Button>标签使用Loading组件 
Vue.component('Button', Button);
```

### 全局组件-插件

1. 子组建添加install方法
2. 在main.js中引用
3. 使用Vue.use（）方法
4. 在页面中使用

```js
// Button.js 

import ButtonComponent from './Button.vue'

// 1.添加install方法 （插件方法）
const Button = {
  install (Vue) {
    Vue.component("Button", ButtonComponent);
  }
}

// 导出Button
export default Button

```

::: tip
也可处理多个全局组件，install可以处理更多事情
:::

```js
// Button.js 

import ButtonComponent1 from './Button1.vue'
import ButtonComponent2 from './Button2.vue'
import ButtonComponent3 from './Button3.vue'

const buttonList = [
    ButtonComponent1,
    ButtonComponent2,
    ButtonComponent3
];
// 1.添加install方法 （插件方法）
const Button = {
  install (Vue，options) {
    buttonList.forEach(button=>{
        // 这里 使用每个组件的 name 属性作为组件名
        Vue.component(button.name, button);
    })
    
  // 更多事情
      // 添加全局方法或属性
  Vue.myGlobalMethod = function () {
    // 逻辑...
  }

  // 添加全局资源
  Vue.directive('my-directive', {
    bind (el, binding, vnode, oldVnode) {
      // 逻辑...
    }
    ...
  })

  // 注入组件选项
  Vue.mixin({
    created: function () {
      // 逻辑...
    }
    ...
  })

  // 添加实例方法
  Vue.prototype.$myMethod = function (methodOptions) {
    // 逻辑...
  }
}

// 导出Button
export default Button
```

```js
// main.js

import Vue from 'vue'
import App from './App.vue'
// 2. 导入 
import Button from '@/components/Button.js'
// 3. 使用 必须在new Vue之前
Vue.use(Button);
new Vue({
  render: h => h(App),
}).$mount('#app')

```

```vue
// 4 任意页面，比如app.vue

<template>
  <div id="app">
    <!-- 5. 在页面上使用 -->
    <Button color="blue">我是全局按钮</Button>
  </div>
</template>
```

### 构造组件

1. Vue.extend 构建组件
2. 挂载到Vue.prototype
3. 在页面的script内使用

```js
// 1. 构建组件
import Vue from 'vue'
// 将复用的页面导入
import Comp from './index.vue'
// 构造组件
let Constructor = Vue.extend(Comp)
let instance
const CustomFieldSetting = {
    //options: {code:动态表code, max:最大勾选数, title:标题}, callback: 确定后的回调
    show (options, callback) {
        if (!instance) {
			// 创造实例，isntance就相当于vue的this
            instance = new Constructor({})
			// 渲染
            instance.$mount()
			// 挂载
            document.body.appendChild(instance.$el)
        }
        instance.init(options, callback)
        instance.visible = true
    }
}
export default CustomFieldSetting
```

```js
// 2.挂载到prototype
import Vue from 'vue'
import CustomFieldSetting from './custom-field-setting'

Vue.prototype.$CustomFieldSetting = CustomFieldSetting
```

```js
// 3.页面上使用
this.$CustomFieldSetting.show({...})
```

#### 代码实例(Vue.extend+单列模式)

##### 单列模式

在使用element时候用到全局组件，比如loading, notify,message等

```js
const loading = this.$loading()
const loading1 = this.$loading()
setTimeout(() => {
  loading.close()
}, 1000 * 3)
// 这时候你会发现，我调用了两次loading,但是只出现了一个，而且我只关闭了loading，但是loading1也被关闭了。
```

##### 实现方式

###### 开发`loading`组件

```vue
<template>
  <transition name="custom-loading-fade">
    <!--loading蒙版-->
    <div v-show="visible" class="custom-loading-mask">
      <!--loading中间的图标-->
      <div class="custom-loading-spinner">
        <i class="custom-spinner-icon"></i>
        <!--loading上面显示的文字-->
        <p class="custom-loading-text">{{ text }}</p>
      </div>
    </div>
  </transition>
</template>
<script>
export default {
  props: {
  // 是否显示loading
    visible: {
      type: Boolean,
      default: false
    },
    // loading上面的显示文字
    text: {
      type: String,
      default: ''
    }
  }
}
</script>
```

开发出来`loading`组件之后，如果需要直接使用，就要这样去用

```vue
<template>
  <div class="component-code">
    <!--其他一堆代码-->
    <custom-loading :visible="visible" text="加载中" />
  </div>
</template>
<script>
export default {
  data() {
    return {
      visible: false
    }
  }
}
</script>
```

但这样使用并不能满足我们的需求

1. 可以通过js直接调用方法来显示关闭
2. `loading`可以将整个页面全部遮罩起来

###### 通过`Vue.extend`将组件转换为全局组件

1. 改造`loading`组件，将组件的`props`改为`data`

```vue
export default {
  data() {
    return {
      text: '',
      visible: false
    }
  }
}
```

2. 通过`Vue.extend`改造组件

```js
// loading/index.js
import Vue from 'vue'
import LoadingComponent from './loading.vue'

// 通过Vue.extend将组件包装成一个子类
const LoadingConstructor = Vue.extend(LoadingComponent)

let loading = undefined

LoadingConstructor.prototype.close = function() {
  // 如果loading 有引用，则去掉引用
  if (loading) {
    loading = undefined
  }
  // 先将组件隐藏
  this.visible = false
  // 延迟300毫秒，等待loading关闭动画执行完之后销毁组件
  setTimeout(() => {
    // 移除挂载的dom元素
    if (this.$el && this.$el.parentNode) {
      this.$el.parentNode.removeChild(this.$el)
    }
    // 调用组件的$destroy方法进行组件销毁
    this.$destroy()
  }, 300)
}

const Loading = (options = {}) => {
  // 如果组件已渲染，则返回即可
  if (loading) {
    return loading
  }
  // 要挂载的元素
  const parent = document.body
  // 组件属性
  const opts = {
    text: '',
    ...options
  }
  // 通过构造函数初始化组件 相当于 new Vue()
  const instance = new LoadingConstructor({
    el: document.createElement('div'),
    data: opts
  })
  // 将loading元素挂在到parent上面
  parent.appendChild(instance.$el)
  // 显示loading
  Vue.nextTick(() => {
    instance.visible = true
  })
  // 将组件实例赋值给loading
  loading = instance
  return instance
}

export default Loading
```

3. 在页面使用loading

```js
import Loading from './loading/index.js'
export default {
  created() {
    const loading = Loading({ text: '正在加载。。。' })
    // 三秒钟后关闭
    setTimeout(() => {
      loading.close()
    }, 3000)
  }
}
```

通过上面的改造，loading已经可以在全局使用了，如果需要像`element-ui`一样挂载到`Vue.prototype`上面，通过`this.$loading`调用，还需要改造一下

###### 将组件挂载到`Vue.prototype`上面

```js
Vue.prototype.$loading = Loading
// 在export之前将Loading方法进行绑定
export default Loading

// 在组件内使用
this.$loading()
```

## 二次封装组件

::: tip
`$attrs`: 当组件在调用时传入的属性没有在`props`里面定义时，传入的属性将被绑定到`$attrs`属性内（`class`与`style`除外，他们会挂载到组件最外层元素上）。并可通过`v-bind="$attrs"`传入到内部组件中。
:::

::: tip
`$listeners`: 当组件被调用时，外部监听的这个组件的所有事件都可以通过`$listeners`获取到。并可通过`v-on="$listeners"`传入到内部组件中。(使用修饰符.native无效)
:::

### 比如二次封装el-dialog

#### 定义基本弹框代码

```vue
<template>
  <el-dialog :visible.sync="visibleDialog" append-to-body>
    <!--内容区域的默认插槽-->
    <slot></slot>
    <!--使用弹框的footer插槽添加按钮-->
    <template #footer>
      <!--对外继续暴露footer插槽，有个别弹框按钮需要自定义-->
      <slot name="footer">
        <!--将取消与确定按钮集成到内部-->
        <span>
          <el-button @click="$_handleCancel">取 消</el-button>
          <el-button type="primary" @click="$_handleConfirm">
            确 定
          </el-button>
        </span>
      </slot>
    </template>
  </el-dialog>
</template>
<script>
export default {
  props: {
    // 对外暴露visible属性，用于显示隐藏弹框
    visible: {
      type: Boolean,
      default: false
    }
  },
  computed: {
    // 通过计算属性，对.sync进行转换，外部也可以直接使用visible.sync
    visibleDialog: {
      get() {
        return this.visible;
      },
      set(val) {
        this.$emit("update:visible", val);
      }
    }
  },
  methods: {
    // 对外抛出cancel事件
    $_handleCancel() {
      this.$emit("cancel");
    },
    // 对外抛出 confirm事件
    $_handleConfirm() {
      this.$emit("confirm");
    }
  }
}
</script>
```

#### 使用二次组件

```vue
<!--外部使用方式 confirm cancel 是自定义的事件 opened是包装el-dialog的事件，通过$listeners传入到el-dialog里面-->
<custom-dialog :visible.sync="visibleDialog" @opened="$_handleOpened" @confirm="$_handleConfirm" @cancel="$_handleCancel">这是一段内容</custom-dialog>
```

但上面的代码存在一个问题，无法将Dialog自身的属性和事件暴露到外部（虽然可以通过props及$emit一个一个添加，但是很麻烦）,这时候就可以使用$attrs与$listeners

#### 使用`$attrs`与`$listeners`

```vue
<!---使用了v-bind与v-on监听属性与事件-->
<template>
    <el-dialog :visible.sync="visibleDialog" v-bind="$attrs" v-on="$listeners">
    <!--其他代码不变-->
    </el-dialog>
</template>
<script>
  export default {
    //默认情况下父作用域的不被认作 props 的 attribute 绑定 (attribute bindings) 
    //将会“回退”且作为普通的 HTML attribute 应用在子组件的根元素上。
    //通过设置 inheritAttrs 到 false，这些默认行为将会被去掉
    inheritAttrs: false
 }
</script>

<!---外部使用方式-->
<custom-dialog
  :visible.sync="visibleDialog"
  title="测试弹框"
  @opened="$_handleOpened"
>
  这是一段内容
</custom-dialog>
```

#### 对于`$attrs`，也可以使用`$props`来代替

```vue
<template>
  <el-dialog :visible.sync="visibleDialog" v-bind="$props" v-on="$listeners">
    <!--其他代码不变-->
  </el-dialog>
</template>
<script>
import { Dialog } from 'element-ui'
export default {
  props: {
    // 将Dialog的props通过扩展运算符展开到props属性里面
    ...Dialog.props
  }
}
</script>
```

但上面的代码存在一定的缺陷，有些组件存在非`props`的属性，比如对于一些封装的表单组件，我们可能需要给组件传入原生属性，但实际原生属性并没有在组件的`props`上面定义，这时候，如果通过上面的方式去包装组件，那么这些原生组件将无法传递到内部组件里面。

## 使用`require.context`实现前端工程自动化

`require.context`是一个`webpack`提供的Api,通过执行`require.context`函数获取一个特定的上下文,主要是用于实现自动化导入模块。

```js
/**
* @param directory 要搜索的文件夹目录，不能是变量，否则在编译阶段无法定位目录
* @param useSubdirectories  是否搜索子目录
* @param regExp 匹配文件的正则表达式
* @return function 返回一个具有 resolve, keys, id 三个属性的方法
          resolve() 它返回请求被解析后得到的模块 id
          keys() 它返回一个数组，由所有符合上下文模块处理的请求组成。 
          id 是上下文模块里面所包含的模块 id. 它可能在你使用 module.hot.accept 的时候被用到
*/
require.context(directory = 'demo', useSubdirectories = false, regExp = /\.js$/)
```

当一个js里面需要手动引入过多的其他文件夹里面的文件时，就可以使用。

### 可能会用到`require.context`的场景

1. 当我们路由页面比较多的时候，可能会将路由文件拆分成多个，然后再通过`import`引入到`index.js`路由主入口文件中
2. 当使用svg symbol时候，需要将所有的svg图片导入到系统中（建议使用svg-sprite-loader）
3. 开发了一系列基础组件，然后把所有组件都导入到`index.js`中，然后再放入一个数组中，通过遍历数组将所有组件进行安装。

### 注册基础组件

在components里注册了一系列组件

components--index.js

```js
import Vue from 'vue'
const context = require.context('./', false, /\.vue$/)
/**
*	context.keys() 返回所有匹配到的文件路径
*/
context.keys().forEach(key => {
  // 通过context(key)可以获取到对应的文件，default表示export default 导出的内容
  let component = context(key).default
  // 安装vue组件
  Vue.component(component.name, component)
})
```

```js
// 在主入口文件引入mian.js
import Vue from 'vue'
import App from './App'
import router from './router'
import './components'
Vue.config.productionTip = false

/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  components: { App },
  template: '<App/>'
})
```

### router模块自动导入

项目结构：

router              // 路由文件夹

 |__index.js          // 路由组织器：用来初始化路由等等

 |__common.js          // 通用路由：声明通用路由

 |__modules           // 业务逻辑模块：所以的业务逻辑模块

​    |__index.js       // 自动化处理文件：自动引入路由的核心文件

​    |__text1.js        // 业务模块text1

​    |__text2.js         // 业务模块text2

#### A.modules模块

index.js内容：

```js
const files = require.context('.', true, /\.js$/)
console.log(files.keys()) // ["./index.js", "./text1.js", "./text2.js"] 返回一个数组
let configRouters = []
// /**
// * inject routers
// */
files.keys().forEach(key => {
	// 去除index.js这项
	if (key === './index.js') return
	// 拼接成一个数组
	configRouters = configRouters.concat(files(key).default) // 读取出文件中的default模块
})
export default configRouters // 抛出一个Vue-router期待的结构的数组
```

业务text1.js和text2.js内容：

```js
export default [
	 {
	   path: '/text1',
	   name: 'text1',
	   component: () => import('../../views/Text1.vue'),
	   desc: '测试1'
	 }
]
```

#### B.common.js

common路由处理 我们的项目中有一大堆的公共路由需要处理比如404，503等等路由我们都在common.js中进行处理。

```js
	export default [
	  // 默认页面
	  {
	    path: '/',
	    redirect: '/text1',
	    hidden:true
	  },
	  // 无权限页面
	  // {
	  //   path: '/nopermission',
	  //   name: 'nopermission',
	  //   component: () => import('@/views/NoPermission')
	  // },
	  // // 404
	  // {
	  //   path: '*',
	  //   name: 'lost',
	  //   component: () => import('@/views/404')
	  // }
	]
```

#### C.index.js

初始化我们的项目路由

```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import RouterConfig from './modules' // 引入业务逻辑模块
import CommonRouters from './common' // 引入通用模块
Vue.use(VueRouter)
export default new VueRouter({
	 // mode: 'history',// 需要服务端支持
	 scrollBehavior: () => ({ y: 0 }),
	 routes: RouterConfig.concat(CommonRouters)
})
```

## 插槽

### 默认插槽





## 深度`watch`与`watch`立即触发回调(侦听器)

### 基础用法

比如一个列表页，我们希望用户在搜索框输入搜索关键字的时候，可以自动触发搜索,此时除了监听搜索框的`change`事件之外，我们也可以通过`watch`监听搜索关键字的变化

```vue
<template>
  <!--此处示例使用了element-ui-->
  <div>
    <div>
      <span>搜索</span>
      <input v-model="searchValue" />
    </div>
    <!--列表，代码省略-->
  </div>
</template>
<script>
export default {
  data() {
    return {
      searchValue: ''
    }
  },
  watch: {
    // 在值发生变化之后，重新加载数据
    searchValue(newValue, oldValue) {
      // 判断搜索
      if (newValue !== oldValue) {
        this.$_loadData()
      }
    }
  },
  methods: {
    $_loadData() {
      // 重新加载数据，此处需要通过函数防抖
    }
  }
}
</script>
```

### 立即触发

通过上面的代码，现在已经可以在值发生变化的时候触发加载数据了，但是如果要在页面初始化时候加载数据，我们还需要在`created`或者`mounted`生命周期钩子里面再次调用`$_loadData`方法。不过，现在可以不用这样写了，通过配置`watch`的立即触发属性，就可以满足需求了

```js
// 改造watch
export default {
  watch: {
    // 在值发生变化之后，重新加载数据
    searchValue: {
    // 通过handler来监听属性变化, 初次调用 newValue为""空字符串， oldValue为 undefined
      handler(newValue, oldValue) {
        if (newValue !== oldValue) {
          this.$_loadData()
        }
      },
      // 配置立即执行属性
      immediate: true
    }
  }
}
```

### 深度监听

一个表单页面，需求希望用户在修改表单的任意一项之后，表单页面就需要变更为被修改状态。如果按照上例中`watch`的写法，那么我们就需要去监听表单每一个属性，太麻烦了，这时候就需要用到`watch`的深度监听`deep`

```js
export default {
  data() {
    return {
      formData: {
        name: '',
        sex: '',
        age: 0,
        deptId: ''
      }
    }
  },
  watch: {
    // 在值发生变化之后，重新加载数据
    formData: {
      // 需要注意，因为对象引用的原因， newValue和oldValue的值一直相等
      handler(newValue, oldValue) {
        // 在这里标记页面编辑状态
      },
      // 通过指定deep属性为true, watch会监听对象里面每一个值的变化
      deep: true
    }
  }
}
```

### 随时监听，随时取消，了解一下`$watch`

有这样一个需求，有一个表单，在编辑的时候需要监听表单的变化，如果发生变化则保存按钮启用，否则保存按钮禁用。这时候对于新增表单来说，可以直接通过`watch`去监听表单数据(假设是`formData`),如上例所述，但对于编辑表单来说，表单需要回填数据，这时候会修改`formData`的值，会触发`watch`,无法准确的判断是否启用保存按钮。现在你就需要了解一下`$watch

```js
export default {
  data() {
    return {
      formData: {
        name: '',
        age: 0
      }
    }
  },
  created() {
    this.$_loadData()
  },
  methods: {
    // 模拟异步请求数据
    $_loadData() {
      setTimeout(() => {
        // 先赋值
        this.formData = {
          name: '子君',
          age: 18
        }
        // 等表单数据回填之后，监听数据是否发生变化
        const unwatch = this.$watch(
          'formData',
          () => {
            console.log('数据发生了变化')
          },
          {
            deep: true
          }
        )
        // 模拟数据发生了变化
        setTimeout(() => {
          this.formData.name = '张三'
        }, 1000)
      }, 1000)
    }
  }
}
```

根据上例可以看到，我们可以在需要的时候通过`this.$watch`来监听数据变化。那么如何取消监听呢，上例中`this.$watch`返回了一个值`unwatch`,是一个函数，在需要取消的时候，执行 `unwatch()`即可取消

## 函数式组件

什么是函数式组件？可以理解为没有内部状态，没有生命周期钩子函数，没有`this`(不需要实例化的组件)。

在日常写bug的过程中，经常会开发一些纯展示性的业务组件，比如一些详情页面，列表界面等，它们有一个共同的特点是只需要将外部传入的数据进行展现，不需要有内部状态，不需要在生命周期钩子函数里面做处理，这时候你就可以考虑使用函数式组件。

### 函数式组件的代码

```js
export default {
  // 通过配置functional属性指定组件为函数式组件
  functional: true,
  // 组件接收的外部属性
  props: {
    avatar: {
      type: String
    }
  },
  /**
   * 渲染函数
   * @param {*} h
   * @param {*} context 函数式组件没有this, props, slots等都在context上面挂着
   */
  render(h, context) {
    const { props } = context
    if (props.avatar) {
      return <img src={props.avatar}></img>
    }
    return <img src="default-avatar.png"></img>
  }
}
```

在上例中，我们定义了一个头像组件，如果外部传入头像，则显示传入的头像，否则显示默认头像。上面的代码中大家看到有一个render函数，这个是`Vue`使用`JSX`的写法。

#### 为什么使用函数式组件

1. 最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件
2. 函数式组件结构比较简单，代码结构更清晰

#### 函数式组件与普通组件的区别

1. 函数式组件需要在声明组件时指定functional
2. 函数式组件不需要实例化，所以没有`this`,`this`通过`render`函数的第二个参数来代替
3. 函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等
4. 函数式组件不能通过$emit对外暴露事件，调用事件只能通过`context.listeners.click`的方式调用外部传入的事件
5. 因为函数式组件是没有实例化的，所以在外部通过`ref`去引用组件时，实际引用的是`HTMLElement`
6. 函数式组件的`props`可以不用显示声明，所以没有在`props`里面声明的属性都会被自动隐式解析为`prop`,而普通组件所有未声明的属性都被解析到`$attrs`里面，并自动挂载到组件根元素上面(可以通过`inheritAttrs`属性禁止)

#### 不想用`JSX`，能用函数式组件吗？

在`Vue2.5`之前，使用函数式组件只能通过`JSX`的方式，在之后，可以通过模板语法来生命函数式组件

```vue
<!--在template 上面添加 functional属性-->
<template functional>
  <img :src="props.avatar ? props.avatar : 'default-avatar.png'" />
</template>
<!--根据上一节第六条，可以省略声明props-->
```

## 计算属性 computed属性

- 模板中放入太多的逻辑会让模板过重且难以维护     使用计算属性可以让模板更加的简洁（插值表达式逻辑太复杂）
- **计算属性是基于它们的响应式依赖进行缓存的**，methods也能实现同样效果，但是性能会差点

### 基本用法

```js
computed: {
	reversedMessage () {
		return this.msg.split('').reverse().join('')  // 默认使用了getter属性
	}
} //需要把结果return出来
//模板使用
{{reversedMessage}}
```

### get和set

一般情况下，**我们只是使用了computer中的gettter属性，默认只有 getter，我们只是单纯的使用了gettter属性**，只有当computed监测的值变化的时候，也就是我下面例子中的fullName变化的时候，set才回被调用。

- get是基于其他的数据来获取到computed里定义的那个数据
- set是根据computed里定义的那个数据来改变其他的数据

```js
<html>
  <head>
    <title>vue5 全选</title>
  </head>
<style>
    
</style>

<body>
    <div id="app">
        <ul>
            <li ><span><input type="checkbox" v-model="allcheck"/></span>全选</li><br/>
            <li v-for="item in datalist"><span><input type="checkbox" v- model="item.status"/></span>{{item.xueli}}</li><br/>
        </ul>
        <input type="button" value="批量操作" />
    </div>
        
</body>
<script src="vue.js"></script>
<script src="axios.min.js"></script>


<script>
    var datalist=[
      {id:1,xueli:'小学',status:false},
      {id:2,xueli:'初中',status:false},
      {id:3,xueli:'高中',status:false},
      {id:4,xueli:'大学',status:true}
    ];
    var vm=new Vue({
        el:"#app",
        data:{        
            
              datalist:datalist
           
        },
        computed:{
            allcheck:{
            get () {
            	var newarr=[];
              newarr = this.datalist.filter(function(item){
              return !item.status;
             })
             if(newarr.length==0){
              return true;
              }
            },
            set(value){
            	this.datalist.forEach(function(item){item.status=value});
            }
            }
        }
        
    });
</script>
</html>
```

## filter 过滤器

格式化数据，比如将字符串格式化为首字母大写，将日期格式化为指定的格式等。

过滤器不改变真正的data，而只是改变渲染的结果，并返回过滤后的版本。

```js
// 全局
//value就是要处理的数据
Vue.filter(‘过滤器名称’, function(value){
	// 过滤器业务逻辑
	return   js逻辑处理结果
})

// 使用
// 过滤器可以用在：双花括号插值表达式
<div>{{msg | upper}}</div>
// 支持级联操作
<div>{{msg | upper | lower}}</div>
// 过滤器可以用在：绑定属性时候即v-bind表达式。
<div v-bind:id=“id | formatId"></div> 


// 局部
filters: { 
  capitalize: function(value){
			return  处理结果
	} 
} 
```

## 自定义指令

之前用单列加vue.extend实现过挂载到全局loading

element还通过v-loading指令。

1. 可以将`loading`挂载到某一个元素上面。
2. 可以使用指令在指定的元素上面挂载`loading`

### 开发`v-loading`指令

```js
import Vue from 'vue'
import LoadingComponent from './loading'
// 使用 Vue.extend构造组件子类
const LoadingContructor = Vue.extend(LoadingComponent)

// 定义一个名为loading的指令
Vue.directive('loading', {
  /**
   * 只调用一次，在指令第一次绑定到元素时调用，可以在这里做一些初始化的设置
   * @param {*} el 指令要绑定的元素
   * @param {*} binding 指令传入的信息，包括 {name:'指令名称', value: '指令绑定的值',arg: '指令参数 v-bind:text 对应 text'}
   */
  bind(el, binding) {
    const instance = new LoadingContructor({
      el: document.createElement('div'),
      data: {}
    })
    el.appendChild(instance.$el)
    el.instance = instance
    Vue.nextTick(() => {
      el.instance.visible = binding.value
    })
  },
  /**
   * 所在组件的 VNode 更新时调用
   * @param {*} el
   * @param {*} binding
   */
  update(el, binding) {
    // 通过对比值的变化判断loading是否显示
    if (binding.oldValue !== binding.value) {
      el.instance.visible = binding.value
    }
  },
  /**
   * 只调用一次，在 指令与元素解绑时调用
   * @param {*} el
   */
  unbind(el) {
    const mask = el.instance.$el
    if (mask.parentNode) {
      mask.parentNode.removeChild(mask)
    }
    el.instance.$destroy()
    el.instance = undefined
  }
})

```

### 在元素上面使用指令

```vue
<template>
  <div v-loading="visible"></div>
</template>
<script>
export default {
  data() {
    return {
      visible: false
    }
  },
  created() {
    this.visible = true
    fetch().then(() => {
      this.visible = false
    })
  }
}
</script>
```

### 项目中哪些场景可以自定义指令

1. 为组件添加`loading`效果
2. 按钮级别权限控制 `v-permission`
3. 代码埋点,根据操作类型定义指令
4. input输入框自动获取焦点
5. 其他等等。。。



## Vue.observable实现状态管理

小型项目进行各组件传值，可以使用该api

### 创建 `store`

```js
import Vue from 'vue'

// 通过Vue.observable创建一个可响应的对象
export const store = Vue.observable({
  userInfo: {},
  roleIds: []
})

// 定义 mutations, 修改属性
export const mutations = {
  setUserInfo(userInfo) {
    store.userInfo = userInfo
  },
  setRoleIds(roleIds) {
    store.roleIds = roleIds
  }
}
```

### 在组件中引用

```vue
<template>
  <div>
    {{ userInfo.name }}
  </div>
</template>
<script>
import { store, mutations } from '../store'
export default {
  computed: {
    userInfo() {
      return store.userInfo
    }
  },
  created() {
    mutations.setUserInfo({
      name: '子君'
    })
  }
}
</script>
```

## `hookEvent`监听组件生命周期

### 1. 内部监听生命周期函数

echarts

```vue
<template>
  <div class="echarts"></div>
</template>
<script>
export default {
  mounted() {
    this.chart = echarts.init(this.$el)
    // 请求数据，赋值数据 等等一系列操作...
    // 监听窗口发生变化，resize组件
    window.addEventListener('resize', this.$_handleResizeChart)
  },
  updated() {
    // 干了一堆活
  },
  created() {
    // 干了一堆活
  },
  beforeDestroy() {
    // 组件销毁时，销毁监听事件
    window.removeEventListener('resize', this.$_handleResizeChart)
  },
  methods: {
    $_handleResizeChart() {
      this.chart.resize()
    },
    // 其他一堆方法
  }
}
</script>
```

但是现在两段代码分开而且相隔几百行代码，可读性比较差，应该将监听`resize`事件与销毁`resize`事件放到一起

```js
export default {
  mounted() {
    this.chart = echarts.init(this.$el)
    // 请求数据，赋值数据 等等一系列操作...
    
    // 监听窗口发生变化，resize组件
    window.addEventListener('resize', this.$_handleResizeChart)
    // 通过hook监听组件销毁钩子函数，并取消监听事件
    this.$once('hook:beforeDestroy', () => {
      window.removeEventListener('resize', this.$_handleResizeChart)
    })
  },
  updated() {},
  created() {},
  methods: {
    $_handleResizeChart() {
      // this.chart.resize()
    }
  }
}
```

::: tip

*在`Vue`组件中，可以用过`$on`,`$once`去监听所有的生命周期钩子函数，如监听组件的`updated`钩子函数可以写成 `this.$on('hook:updated', () => {})`*

:::

### 2. 外部监听生命周期函数

用了一个第三方组件，需要监听第三方组件数据的变化，但是组件又没有提供`change`事件，只能在外部监听组件的`updated`钩子函数。

```vue
<template>
  <!--通过@hook:updated监听组件的updated生命钩子函数-->
  <!--组件的所有生命周期钩子都可以通过@hook:钩子函数名 来监听触发-->
  <custom-select @hook:updated="$_handleSelectUpdated" />
</template>
<script>
import CustomSelect from '../components/custom-select'
export default {
  components: {
    CustomSelect
  },
  methods: {
    $_handleSelectUpdated() {
      console.log('custom-select组件的updated钩子函数被触发')
    }
  }
}
</script>
```



## 生命钩子函数



<<<<<<< HEAD

## 监听窗口变化调整dom大小

```vue
mounted () {
// 挂载监听
	window.addEventListener('resize', this.calHeight)
// 取消监听
	this.$once('hook:beforeDestroy', () => {  		  
    window.removeEventListener('resize', this.calHeight)
	})
},
activated () {
  // 切换时候也重新设置大小
	this.$nextTick(() => {    
		this.calHeight()
	})
},
methods: {
	calHeight () {  
		if (this.$refs.container && this.$refs.header && this.$refs.top) {
		this.tableHeight = this.$refs.container.offsetHeight - 		this.$refs.top.offsetHeight - this.$refs.header.offsetHeight - 35 + 'px' }
	}
}
```

=======
## 

>>>>>>> 107c1268a564bc14c2f4e277ce8cd0dd8b07fb6d



## 定时器使用

### 方式一、

```vue
<template>
	<view>
		<button @click="getStatus">{{ buttonText }}</button>
	</view>
</template>
<script>
	export default {
		data() {
			return {
				timer: null, //首先我在data函数里面进行定义定时器名称：
				buttonText : '轮询获取订单支付状态',
				timerNum: 60 // 设置定时器时间
			}
		},
		methods: {
			getStatus() {
				this.loading(); // 启动定时器
				this.timer = setInterval(() => {  //创建定时器
					if (this.timerNum === 0) { // 设置的定时器时间为0后执行的操作
						this.timer && this.clearTimer(); // 关闭定时器
						window.open('码灵导航 - 程序员网址导航', '_blank'); // 在新窗口打开程序员网址导航
					} else {
						this.loading();
					}
				}, 1000);
			},
			loading() { // 启动定时器
				this.timerNum -= 1; // 定时器减1
				this.text = '获取中(' + this.timerNum + ')';
			},
			clearTimer() {//清除定时器
				clearInterval(this.timer);
				this.timer = null;
			}
		},
		// 最后在beforeDestroy()生命周期内清除定时器：
		beforeDestroy() {
		    clearInterval(this.timer);        
		    this.timer = null;
		}
	}
</script>
```

### 方式二

```vue
// 定时器
setTimeHandle () {
	// 执行
	const timer = setInterval(() => {
	setTimeout(() => {
			// 处理事情
		}, 0)
	}, 60000)
	// 清除
	this.$once('hook:beforeDestroy', () => {
		console.log('清除定时器')
		clearInterval(timer)
	})
}
```

### 方式三

```

```

## 获取时间

```vue
    // 获取距离第二天凌晨时间
    getTomorrowTime (time) {
      // 获取当前时间 毫秒
      let m1 = time.getTime()
      // 设置昨天凌晨
      time.setHours(0)
      time.setMinutes(0)
      time.setSeconds(0)
      // 获取昨天凌晨时间 毫秒
      let m0 = time.getTime()
      // 获取距离明天的毫秒
      return 60 * 60 * 24 * 1000 - (m1 - m0)
    },
```

